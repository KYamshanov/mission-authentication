Микросервис авторизации проекта mission

Для регистрации нового пользователя в МС используется End-point (POST) : /reg, который принимает логин и пароль нового
пользователя.
Юзер сохраняется в PostgresSQL таблице 'auth_users', если такого пользователя в БД нет

Для аутентификации используется End-point (POST) : /login, который принимает логин, пароль и информацию о пользователе(
например отпечаток устройства).
Если логин и пароль соответствуют сохраненным в БД, то генерируются access и
refresh токены
которые возвращаются как результат. Так же сохраняется информация о сессии по refresh токену в таблице 'auth_tokens'

Для проверки активности access токена используется End-point (POST) : /check который принимает access токен.
Полученный токен дешифрируется с проверкой сигнатуры, если тип токена не ACCESS или значение expiresAt меньше текущего
времени, то возвращается ошибка

Для востановления протухшего access токена используется End-point (POST) : /refresh который принимает refresh токен и
информацию о пользователе
Полученный токен дешифрируется с проверкой сигнатуры, если тип токена не REFRESH или значение expiresAt меньше текущего
времени, то возвращается ошибка. Из БД получаем информацию о сессии по refresh токену, сверяем время действия токена из
таблицы, проверяем статус сесии и если статус ACTIVE, то генерируется новая пара access, refresh токенов. В случае если
информация о сессии идентична полученной из тела запроса, то информация о сессии переписывается иначе у старой записи
изменяется статус на INVALID и сохраняется новое значение сессии

Для блокировки сессии т.е. refresh токена используем End-point (POST) : /block который принимает refresh jwt токен.
Полученный токен дешифрируется с проверкой сигнатуры, в БД 'auth_tokens' находим соответствующую запись сессии и
изменяет статус на PAUSED

Хеширование пароля:
Для хеширования пароля используем алгоритм Argon2 как наиболее современный и безопасный.
Основанием использования этого алгоритма является
статья https://medium.com/analytics-vidhya/password-hashing-pbkdf2-scrypt-bcrypt-and-argon2-e25aaf41598e
А также информация из
документации https://docs.spring.io/spring-security/reference/features/authentication/password-storage.html#authentication-password-storage-argon2

Алгоритм шифрования для JWT
Шифрование и дешифрование JWT токена должно происходить в нашей системе только на данном МС(mission-authentication),
поэтому будем использовать алгоритм HMAC, который принимает только приватный ключ(secret), а использование именно
HMAC256
обусловлено ограниченными вычислительными мощностями.
!при использовании HMAC256 длина секретного ключа должна быть не менее 256 бит.
см.: https://github.com/auth0/java-jwt#hmac-key-length-and-security !

QR авторизация.
Система должна поддерживать авторизацию через куар код.
Для этого создания токена внешней авторизации используется End-point (POST) : /share, который принимает refresh-token.
Данный энд поинт используется для создания share-auth токена, который можно использовать для авторизации вместо логина и
пароля.
Для создания токена проверяется refreshToken на его активность, после создаётся токен и сохраняется информация в БД '
auth_share'
Для авторизации по share-auth токену используется End-point (POST) : /share_login, который принимает токен и информацию
о пользователе. По данному токену происходит инициирование сценария логина по данными владельца токена
Проверяется статус share_auth токена, статус сесии(refresh token) из которого был создан share_auth токен, проверяется
активность share_auth токена, если всё валидно, то генерируется пара access/refresh токена

Блокировка access токена.
Хоть мы и создаём access токен с учётом того, что он нигде не сохраняется, а для обеспечения безопасности каждый токен
подписывается используя алгоритмы шифрования с приватным ключом, который сложно подделать. Поэтому мы считаем, что токен
является идентификатором пользователя, а так же ключом для доступа к ресурсам системы. Для обеспечения безопасности
access токен имеет небольшое время жизни, а чтобы его обновить используется refresh токен
В случае утечки access токена мошенники будут иметь небольшое время на совершение операций, поэтому для критических
систем мы организовываем дополнительную проверку access токенов.
Для обеспечения быстрой скорости проверки access токена, мы не сохраняем данные токены при их создании, а сохраняем по
факту блокировки в Redis БД, что обеспечит быстрый доступ к блокированным токенам.

Redis
Т.к. мы используем reactive stack для редис используем Lettuce коннектор на основании
https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#redis:reactive:connectors:operation-modes

Автоматическое удаление истекших сессий
Первым делом необходимо доратать БД и установить правила на внешние включи: для таблиц auth_tokens, auth_share на
внешние ключи <user_id,session_id> устаналиваем ON DELETE CASCADE правило, т.к. при удалении полей в основных таблицых(
auth_user , auth_token) поля в зависмых таблицых должны удаляться

Интеграция с докером
Для упрощения развертывания инфраструктуры mission каждый микросервис и шлюз должны запускаться через docker-compose
файл Dockerfile и docker-compose.yml должен располагаться в корне проекта
Для взаимодействия между контейнерами используется сеть mission-gateway_mission заданная в настройках gateway

Роли пользователя.
Данный микросервис отвечает за роли пользователя для оптимизации проверок.
Роли пользователя зашиваются в access токене. При check access токена, можно возвращать список ролей пользователя, чтобы
сервисы не занимались доп. парсингом JWT (сервис авторизации делает это по умолчанию)
Пусть по умолчанию каждый пользователь имеет роль USER.